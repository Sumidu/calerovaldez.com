library(memoise)

## setting up memoise functions to prevent rate-ban
get_complete_authors_ <- memoise::memoise(scholar::get_complete_authors)
get_publication_abstract_ <- memoise::memoise(scholar::get_publication_abstract)
get_publication_data_extended_ <- memoise::memoise(scholar::get_publication_data_extended)
get_publication_url_ <- memoise::memoise(scholar::get_publication_url)

#' Function that converts a scholar pub to a usable pub for markdown rendering
#' This adds additional metainformation and corrects dates
#' @param pub a publication from scholar
#' @param scholar_id the id of the scholar of the author
#' @param cross_ref_data the cross ref data for the author
#' @return a publication with additional metainformation
#' @export
convert <- function(pub, scholar_id, cross_ref_data) {


  logging::loginfo(paste("Generating --", pub$title))

  logging::loginfo(paste("Getting coauthors"))
  pub$authors_full <-
    names(get_complete_authors_(id = scholar_id, pubid = pub$pubid))

  logging::loginfo(paste("Getting abstract"))
  pub$abstract <-
    paste(get_publication_abstract_(id = scholar_id, pub_id = pub$pubid),
          collapse = " ")
  # Legend: 0 = Uncategorized; 1 = Conference paper; 2 = Journal article;
  # 3 = Preprint / Working Paper; 4 = Report; 5 = Book; 6 = Book section;
  # 7 = Thesis; 8 = Patent

  # Fallback options
  pub$pub_type <- 2
  pub$source <- pub$journal

  # get all meta data
  fullmeta <- get_publication_data_extended_(id = scholar_id, pub_id = pub$pubid)



  # if Source is set, it is a journal article
  if (!is.null(fullmeta$Source)) {
    pub$source <- fullmeta$Source
    pub$pub_type <- 2
  }
  # if conference is set, it is a conference paper
  if (!is.null(fullmeta$Conference)) {
    pub$source <- fullmeta$Conference
    pub$pub_type <- 1
  }
  # if Journal is set, it is a journal article
  if (!is.null(fullmeta$Journal)) {
    pub$source <- fullmeta$Journal
    pub$pub_type <- 2
  }
  # if Book is set, it is a book section
  if (!is.null(fullmeta$Book)) {
    pub$source <- fullmeta$Book
    pub$pub_type <- 6
  }
  logging::loginfo(paste("Publication type: ", pub$pub_type))

  # fix the date as returned by scholar
  pub$date <- fix_date(fullmeta$`Publication date`)

  # get url link
  url <- get_publication_url_(id = scholar_id, pub_id = pub$pubid)
  # can return zero length character vector
  if(length(url)>0){
    pub$url <- url
  } else {
    pub$url <- ""
  }


  logging::loginfo(paste("Publication URL: ", pub$url))

  pub$doi <- get_doi(pub, cross_ref_data)


  return(pub)
}



#' Fix the date as returned by scholar
#'
#' @param date
#'
#' @return date
#' @export
#'
fix_date <- function(date){
  #date <- "2016"
  newdate <- date
  if(str_length(newdate)<5){
    newdate <- paste0(date, "/01/01")
  }
  if(str_length(newdate)<8){
    newdate <- paste0(date, "/01")
  }

  logging::loginfo(paste("Found date as:",lubridate::ymd(newdate)))

  newdate
}

#' Get the DOI from crossref
#' @param author The author name
#' @param limit The maximum number of results returned
#' @return data frame with results for author
#' @export
get_cr_list <- memoise::memoise(get_cr_list_)

#' Internal function to access the API
#' @param author The author name
#' @param limit The maximum number of results returned
#' @return data frame with results for author
get_cr_list_ <- function(author = "André Calero Valdez", limit = 200){
  crf_results <<- rcrossref::cr_works(
    flq = c(query.author = author),
    limit = limit)

  logging::loginfo(paste("Found ", nrow(crf_results$data), " publications for ", author))
  return(crf_results$data)
}


#' Get the DOI from crossref
#' @param pub The publication
#' @param crl The crossref list
#' @param distance The maximum Levensthein distance for a match
#' @return doi
#' @export
get_doi <- function(pub, crl, distance = 10){

  crl <- crl %>% select(title, doi) %>%
    mutate(title = str_to_lower(title)) %>%
    mutate(title = stringi::stri_trans_general(title, "Latin-ASCII"))

  search_title <- pub$title %>%
    str_to_lower() %>%
    stringi::stri_trans_general("Latin-ASCII")

  match_matrix <- utils::adist(search_title, crl$title, partial = TRUE, ignore.case = TRUE)
  m_idx <- which.min(match_matrix)
  diff <- min(match_matrix)

  if(diff > distance){
    logging::logwarn(paste("No DOI found for ", pub$title))
    doi <- ""
    return(doi)
  }

  doi <- crl$doi[m_idx]
  logging::loginfo(paste("Found DOI ", doi, " for ", pub$title))
  return(doi)
}

#' Function to generate the citekey as it is generated by google scholar
#' @param pub The publication
#' @return citekey
#' @export
gen_citekey <- function(pub){
  #generate google citekey
  stopwords <- c("a", "the", "on", "from", "what", "who", "an",
                 "do", "how", "and", "that", "in", "das", "wo",
                 "ist")

  lastname <- pub$author %>%
    str_split(", ") %>% extract2(1) %>% extract(1) %>% #get first author
    str_split("[[:punct:]]|\\s") %>% extract2(1) %>% extract(2) %>% #get last name
    str_to_lower() %>%
    str_replace_all("ß", "ss") %>%
    str_replace_all("ö", "o") %>%
    str_replace_all("ä", "a") %>%
    str_replace_all("ü", "u") %>%
    str_replace_all("é", "e") %>%
    stringi::stri_trans_general("Latin-ASCII")


  title_words <- pub$title %>%
    str_split("[[:punct:]]|\\s") %>% extract2(1) %>% #get all words
    str_to_lower() %>%
    str_replace_all("[[:punct:]]", "") %>%
    stringi::stri_trans_general("Latin-ASCII")

  title_word <- ""
  # iterate over words
  for (i in 1:length(title_words)) {
    title_word <- title_words[i]
    if(title_word %in% stopwords) { # ignore stop words
      next
    }
    if(str_length(title_word)==0) { # ignore very short word
      next
    }
    break
  }
  # calero2022amazing
  citekey <- paste0(lastname, pub$year, title_word)
  logging::loginfo(paste("Generated citekey: ", citekey))
  citekey
}

